<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®¶è¨ˆç°¿ã‚¢ãƒ—ãƒª</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .file-controls {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
        }

        .btn-gradient-orange {
            background: linear-gradient(45deg, #ffecd2, #fcb69f);
            color: #333;
        }

        .btn-gradient-pink {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            color: #333;
        }

        .btn-gradient-teal {
            background: linear-gradient(45deg, #fdbb2d, #22c1c3);
            color: white;
        }

        .btn-gradient-purple {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }

        .main-content {
            padding: 30px;
        }

        .form-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }

        .form-section h2 {
            color: #495057;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group-aligned-end {
            display: flex;
            align-items: flex-end;
        }

        .form-group label {
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        .form-group input,
        .form-group select {
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #e9ecef;
            transition: transform 0.3s ease;
        }

        .summary-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .summary-card.income {
            border-left: 5px solid #28a745;
        }

        .summary-card.expense {
            border-left: 5px solid #dc3545;
        }

        .summary-card.balance {
            border-left: 5px solid #007bff;
        }

        .summary-card h3 {
            color: #6c757d;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .summary-card .amount {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .summary-card.income .amount {
            color: #28a745;
        }

        .summary-card.expense .amount {
            color: #dc3545;
        }

        .summary-card.balance .amount {
            color: #007bff;
        }

        /* ãƒãƒ£ãƒ¼ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .chart-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }

        .chart-section h2 {
            color: #495057;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .chart-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        @media (max-width: 768px) {
            .chart-container {
                height: 300px;
                padding: 10px;
            }
        }

        .transactions-section {
            background: white;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .transactions-header {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            border-radius: 10px 10px 0 0;
        }

        .transactions-header h2 {
            color: #495057;
            margin-bottom: 15px;
        }

        .filter-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .transactions-table {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
            position: sticky;
            top: 0;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .amount-positive {
            color: #28a745;
            font-weight: 600;
        }

        .amount-negative {
            color: #dc3545;
            font-weight: 600;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-btn:hover {
            background: #c82333;
        }

        .delete-btn:focus {
            outline: 2px solid #dc3545;
            outline-offset: 2px;
        }

        .empty-state {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }

        .empty-state-icon {
            font-size: 3em;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .notification.error {
            background: linear-gradient(45deg, #dc3545, #e83e8c);
        }

        .notification.warning {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
        }

        .notification.info {
            background: linear-gradient(45deg, #17a2b8, #6f42c1);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1500;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
            transform: scale(0.8);
            transition: transform 0.3s ease;
            position: relative;
        }

        .modal-overlay.show .modal-content {
            transform: scale(1);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .category-item {
            display: inline-block;
            background: #f8f9fa;
            padding: 8px 12px;
            margin: 4px;
            border-radius: 20px;
            font-size: 14px;
            border: 1px solid #dee2e6;
            position: relative;
            transition: all 0.2s ease;
        }

        .category-item:hover {
            background: #e9ecef;
        }

        .category-item.income {
            background: #e7f5e7;
            border-color: #28a745;
        }

        .category-item.expense {
            background: #f8e6e6;
            border-color: #dc3545;
        }

        .category-remove {
            background: none;
            border: none;
            color: #dc3545;
            margin-left: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
        }

        .category-remove:hover {
            color: #c82333;
        }

        .form-inline {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }

        .form-inline input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
        }

        .import-options {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .import-options h3 {
            margin-bottom: 15px;
            color: #495057;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .radio-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .radio-option.selected {
            border-color: #667eea;
            background: #e6f3ff;
        }

        .radio-option input[type="radio"] {
            margin-right: 10px;
        }

        .hidden {
            display: none;
        }

        #fileInput, #excelFileInput {
            display: none;
        }

        .loading-spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3000;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 20px;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .full-width-btn {
            width: 100%;
        }

        .margin-right-10 {
            margin-right: 10px;
        }

        .modal-title {
            margin-bottom: 15px;
            color: #495057;
        }

        .modal-text {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .modal-section {
            margin-bottom: 25px;
        }

        .modal-section h3 {
            color: #28a745;
            margin-bottom: 15px;
        }

        .modal-section.expense h3 {
            color: #dc3545;
        }

        .info-line {
            line-height: 1.8;
        }

        .info-line strong {
            font-weight: 600;
        }

        .status-success {
            color: #28a745;
        }

        .status-warning {
            color: #6c757d;
        }

        /* ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ”¹å–„ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        [aria-hidden="true"] {
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .main-content {
                padding: 20px;
            }

            .file-controls {
                flex-direction: column;
                align-items: center;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .summary-cards {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 14px;
            }

            th, td {
                padding: 10px 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1><span aria-hidden="true">ğŸ’°</span> å®¶è¨ˆç°¿ã‚¢ãƒ—ãƒª</h1>
            <p>åå…¥ã¨æ”¯å‡ºã‚’ç°¡å˜ç®¡ç†</p>
        </header>

        <div class="file-controls">
            <button id="exportExcelBtn" class="btn btn-success"><span aria-hidden="true">ğŸ“Š</span> Excelã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            <button id="importExcelBtn" class="btn btn-primary"><span aria-hidden="true">ğŸ“Š</span> Excelã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
            <button id="exportJsonBtn" class="btn btn-success"><span aria-hidden="true">ğŸ“¥</span> JSONã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            <button id="importJsonBtn" class="btn btn-primary"><span aria-hidden="true">ğŸ“¤</span> JSONã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
            <button id="clearDataBtn" class="btn btn-warning"><span aria-hidden="true">ğŸ—‘ï¸</span> å…¨ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢</button>
            <button id="storageInfoBtn" class="btn btn-gradient-orange"><span aria-hidden="true">ğŸ’¾</span> ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±</button>
            <button id="restoreBackupBtn" class="btn btn-gradient-pink"><span aria-hidden="true">ğŸ”„</span> ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¾©å…ƒ</button>
            <input type="file" id="fileInput" accept=".json" aria-label="JSONãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ">
            <input type="file" id="excelFileInput" accept=".xlsx,.xls" aria-label="Excelãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ">
        </div>

        <main class="main-content">
            <div class="form-section">
                <h2>æ–°ã—ã„å–å¼•ã‚’è¿½åŠ </h2>
                <form id="transactionForm">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="date">æ—¥ä»˜</label>
                            <input type="date" id="date" required>
                        </div>
                        <div class="form-group">
                            <label for="type">ç¨®é¡</label>
                            <select id="type" required>
                                <option value="">é¸æŠã—ã¦ãã ã•ã„</option>
                                <option value="income">åå…¥</option>
                                <option value="expense">æ”¯å‡º</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="category">ã‚«ãƒ†ã‚´ãƒª</label>
                            <select id="category" required>
                                <option value="">é¸æŠã—ã¦ãã ã•ã„</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="amount">é‡‘é¡</label>
                            <input type="number" id="amount" required min="1" step="1">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="description">èª¬æ˜</label>
                            <input type="text" id="description" placeholder="èª¬æ˜ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„">
                        </div>
                        <div class="form-group form-group-aligned-end">
                            <button type="button" id="categoryManagerBtn" class="btn btn-gradient-teal full-width-btn margin-right-10"><span aria-hidden="true">âš™ï¸</span> ã‚«ãƒ†ã‚´ãƒªç®¡ç†</button>
                        </div>
                        <div class="form-group form-group-aligned-end">
                            <button type="submit" class="btn btn-primary full-width-btn"><span aria-hidden="true">âœ…</span> è¿½åŠ </button>
                        </div>
                    </div>
                </form>
            </div>

            <div class="summary-cards">
                <div class="summary-card income">
                    <h3>ç·åå…¥</h3>
                    <div class="amount" id="totalIncome">Â¥0</div>
                </div>
                <div class="summary-card expense">
                    <h3>ç·æ”¯å‡º</h3>
                    <div class="amount" id="totalExpense">Â¥0</div>
                </div>
                <div class="summary-card balance">
                    <h3>æ®‹é«˜</h3>
                    <div class="amount" id="balance">Â¥0</div>
                </div>
            </div>

            <!-- ãƒãƒ£ãƒ¼ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®è¿½åŠ  -->
            <div class="chart-section">
                <h2><span aria-hidden="true">ğŸ“Š</span> æœˆåˆ¥åæ”¯ã‚°ãƒ©ãƒ•</h2>
                <div class="chart-controls">
                    <button id="chartPrevBtn" class="btn btn-gradient-purple">â† å‰ã®æœŸé–“</button>
                    <button id="chartCurrentBtn" class="btn btn-gradient-purple">ä»Šæœˆã‚’è¡¨ç¤º</button>
                    <button id="chartNextBtn" class="btn btn-gradient-purple">æ¬¡ã®æœŸé–“ â†’</button>
                    <select id="chartRange" class="btn btn-gradient-purple" style="padding: 10px 20px;">
                        <option value="6">éå»6ãƒ¶æœˆ</option>
                        <option value="12" selected>éå»12ãƒ¶æœˆ</option>
                        <option value="24">éå»24ãƒ¶æœˆ</option>
                        <option value="all">å…¨æœŸé–“</option>
                    </select>
                </div>
                <div class="chart-container">
                    <canvas id="monthlyChart"></canvas>
                </div>
            </div>

            <div class="transactions-section">
                <div class="transactions-header">
                    <h2>å–å¼•å±¥æ­´</h2>
                    <div class="filter-controls">
                        <div class="form-group">
                            <label for="filterType">ç¨®é¡ã§ãƒ•ã‚£ãƒ«ã‚¿</label>
                            <select id="filterType">
                                <option value="">ã™ã¹ã¦</option>
                                <option value="income">åå…¥</option>
                                <option value="expense">æ”¯å‡º</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="filterCategory">ã‚«ãƒ†ã‚´ãƒªã§ãƒ•ã‚£ãƒ«ã‚¿</label>
                            <select id="filterCategory">
                                <option value="">ã™ã¹ã¦</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="filterMonth">æœˆã§ãƒ•ã‚£ãƒ«ã‚¿</label>
                            <input type="month" id="filterMonth">
                        </div>
                    </div>
                </div>
                <div class="transactions-table" role="region" aria-label="å–å¼•å±¥æ­´ä¸€è¦§">
                    <table id="transactionsTable">
                        <thead>
                            <tr>
                                <th scope="col">æ—¥ä»˜</th>
                                <th scope="col">ç¨®é¡</th>
                                <th scope="col">ã‚«ãƒ†ã‚´ãƒª</th>
                                <th scope="col">èª¬æ˜</th>
                                <th scope="col">é‡‘é¡</th>
                                <th scope="col">æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="transactionsBody">
                        </tbody>
                    </table>
                    <div id="emptyState" class="empty-state">
                        <div class="empty-state-icon" aria-hidden="true">ğŸ“Š</div>
                        <h3>ã¾ã å–å¼•ãŒã‚ã‚Šã¾ã›ã‚“</h3>
                        <p>ä¸Šã®ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰æœ€åˆã®å–å¼•ã‚’è¿½åŠ ã—ã¦ãã ã•ã„</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- SheetJS Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <script type="module">
        (() => {
            'use strict';

            // å®šæ•°å®šç¾©
            const CONSTANTS = {
                TRANSACTION_TYPES: {
                    INCOME: 'income',
                    EXPENSE: 'expense'
                },
                NOTIFICATION_TYPES: {
                    SUCCESS: 'success',
                    ERROR: 'error',
                    WARNING: 'warning',
                    INFO: 'info'
                },
                STORAGE_KEYS: {
                    MAIN_DATA: 'householdBudgetData',
                    BACKUP_DATA: 'householdBudgetBackup'
                },
                CSS_CLASSES: {
                    LOADING_SPINNER: 'loading-spinner',
                    MODAL_OVERLAY: 'modal-overlay',
                    MODAL_CONTENT: 'modal-content',
                    SHOW: 'show',
                    HIDDEN: 'hidden'
                },
                DEFAULTS: {
                    NOTIFICATION_DURATION: 3000,
                    DEBOUNCE_DELAY: 500,
                    AUTO_BACKUP_INTERVAL: 100
                },
                INDEXEDDB: {
                    DB_NAME: 'HouseholdBudgetDB',
                    VERSION: 1,
                    STORES: {
                        TRANSACTIONS: 'transactions',
                        SETTINGS: 'settings',
                        BACKUPS: 'backups'
                    }
                },
                CHART: {
                    COLORS: {
                        INCOME: 'rgba(40, 167, 69, 0.8)',
                        EXPENSE: 'rgba(220, 53, 69, 0.8)',
                        INCOME_BORDER: 'rgba(40, 167, 69, 1)',
                        EXPENSE_BORDER: 'rgba(220, 53, 69, 1)'
                    }
                }
            };

            // ã‚¤ãƒ™ãƒ³ãƒˆã‚¨ãƒŸãƒƒã‚¿ãƒ¼å®Ÿè£…
            class EventEmitter {
                constructor() {
                    this.events = {};
                }

                on(event, listener) {
                    if (!this.events[event]) {
                        this.events[event] = [];
                    }
                    this.events[event].push(listener);
                }

                off(event, listenerToRemove) {
                    if (!this.events[event]) return;
                    this.events[event] = this.events[event].filter(listener => listener !== listenerToRemove);
                }

                emit(event, data) {
                    if (!this.events[event]) return;
                    this.events[event].forEach(listener => listener(data));
                }
            }

            // IndexedDBãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
            class IndexedDBManager {
                constructor() {
                    this.db = null;
                    this.dbName = CONSTANTS.INDEXEDDB.DB_NAME;
                    this.version = CONSTANTS.INDEXEDDB.VERSION;
                }

                async init() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName, this.version);

                        request.onerror = () => {
                            reject(new Error('IndexedDBã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                        };

                        request.onsuccess = (event) => {
                            this.db = event.target.result;
                            resolve();
                        };

                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;

                            // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚¹ãƒˆã‚¢
                            if (!db.objectStoreNames.contains(CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS)) {
                                const transactionStore = db.createObjectStore(
                                    CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS,
                                    { keyPath: 'id' }
                                );
                                transactionStore.createIndex('date', 'date', { unique: false });
                                transactionStore.createIndex('type', 'type', { unique: false });
                                transactionStore.createIndex('category', 'category', { unique: false });
                            }

                            // è¨­å®šã‚¹ãƒˆã‚¢
                            if (!db.objectStoreNames.contains(CONSTANTS.INDEXEDDB.STORES.SETTINGS)) {
                                db.createObjectStore(
                                    CONSTANTS.INDEXEDDB.STORES.SETTINGS,
                                    { keyPath: 'key' }
                                );
                            }

                            // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ãƒˆã‚¢
                            if (!db.objectStoreNames.contains(CONSTANTS.INDEXEDDB.STORES.BACKUPS)) {
                                const backupStore = db.createObjectStore(
                                    CONSTANTS.INDEXEDDB.STORES.BACKUPS,
                                    { keyPath: 'id', autoIncrement: true }
                                );
                                backupStore.createIndex('timestamp', 'timestamp', { unique: false });
                            }
                        };
                    });
                }

                async getAllTransactions() {
                    const transaction = this.db.transaction([CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS], 'readonly');
                    const store = transaction.objectStore(CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(new Error('ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                    });
                }

                async addTransaction(transactionData) {
                    const transaction = this.db.transaction([CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS], 'readwrite');
                    const store = transaction.objectStore(CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.add(transactionData);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(new Error('ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                    });
                }

                async deleteTransaction(id) {
                    const transaction = this.db.transaction([CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS], 'readwrite');
                    const store = transaction.objectStore(CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.delete(id);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(new Error('ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                    });
                }

                async clearTransactions() {
                    const transaction = this.db.transaction([CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS], 'readwrite');
                    const store = transaction.objectStore(CONSTANTS.INDEXEDDB.STORES.TRANSACTIONS);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.clear();
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(new Error('ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¯ãƒªã‚¢ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                    });
                }

                async saveSettings(settings) {
                    const transaction = this.db.transaction([CONSTANTS.INDEXEDDB.STORES.SETTINGS], 'readwrite');
                    const store = transaction.objectStore(CONSTANTS.INDEXEDDB.STORES.SETTINGS);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.put({ key: 'main', ...settings });
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(new Error('è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                    });
                }

                async getSettings() {
                    const transaction = this.db.transaction([CONSTANTS.INDEXEDDB.STORES.SETTINGS], 'readonly');
                    const store = transaction.objectStore(CONSTANTS.INDEXEDDB.STORES.SETTINGS);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.get('main');
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(new Error('è¨­å®šã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                    });
                }

                async createBackup(backupData) {
                    const transaction = this.db.transaction([CONSTANTS.INDEXEDDB.STORES.BACKUPS], 'readwrite');
                    const store = transaction.objectStore(CONSTANTS.INDEXEDDB.STORES.BACKUPS);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.add({
                            timestamp: new Date().toISOString(),
                            data: backupData
                        });
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(new Error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ'));
                    });
                }

                async getLatestBackup() {
                    const transaction = this.db.transaction([CONSTANTS.INDEXEDDB.STORES.BACKUPS], 'readonly');
                    const store = transaction.objectStore(CONSTANTS.INDEXEDDB.STORES.BACKUPS);
                    const index = store.index('timestamp');
                    
                    return new Promise((resolve, reject) => {
                        const request = index.openCursor(null, 'prev');
                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            resolve(cursor ? cursor.value : null);
                        };
                        request.onerror = () => reject(new Error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                    });
                }
            }

            // ãƒ‡ãƒ¼ã‚¿ç®¡ç†ã‚¯ãƒ©ã‚¹ï¼ˆIndexedDBå¯¾å¿œç‰ˆï¼‰
            class HouseholdBudgetData extends EventEmitter {
                constructor() {
                    super();
                    this.transactions = [];
                    this.filteredTransactions = [];
                    this.idCounter = 1;
                    this.categories = {
                        [CONSTANTS.TRANSACTION_TYPES.INCOME]: ['çµ¦ä¸', 'ãƒœãƒ¼ãƒŠã‚¹', 'å‰¯æ¥­', 'æŠ•è³‡', 'ãã®ä»–åå…¥'],
                        [CONSTANTS.TRANSACTION_TYPES.EXPENSE]: ['é£Ÿè²»', 'äº¤é€šè²»', 'å…‰ç†±è²»', 'é€šä¿¡è²»', 'å¨¯æ¥½', 'åŒ»ç™‚è²»', 'è¡£æœ', 'æ—¥ç”¨å“', 'ãã®ä»–æ”¯å‡º']
                    };
                    this.filters = { type: '', category: '', month: '' };
                    this.dbManager = new IndexedDBManager();
                    this.isInitialized = false;
                    
                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ç”¨ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
                    this.summaryCache = null;
                    this.lastSummaryUpdate = null;
                }

                async init() {
                    try {
                        await this.dbManager.init();
                        const transactions = await this.dbManager.getAllTransactions();
                        this.transactions = transactions || [];
                        
                        const settings = await this.dbManager.getSettings();
                        if (settings) {
                            this.categories = settings.categories || this.categories;
                            this.filters = settings.filters || this.filters;
                            this.idCounter = settings.idCounter || this.idCounter;
                        }
                        
                        this.isInitialized = true;
                        this.emit('dataLoaded');
                        this.emit('dataChanged');
                    } catch (error) {
                        console.error('IndexedDBåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: localStorageã‹ã‚‰èª­ã¿è¾¼ã¿
                        this.loadFromLocalStorage();
                    }
                }

                loadFromLocalStorage() {
                    try {
                        const savedData = localStorage.getItem(CONSTANTS.STORAGE_KEYS.MAIN_DATA);
                        if (savedData) {
                            const parsedData = JSON.parse(savedData);
                            if (Array.isArray(parsedData)) {
                                this.transactions = parsedData;
                            } else {
                                this.fromSaveFormat(parsedData);
                            }
                        }
                        this.isInitialized = true;
                        this.emit('dataLoaded');
                        this.emit('dataChanged');
                    } catch (error) {
                        console.error('localStorageèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    }
                }

                generateUniqueId() {
                    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                        return crypto.randomUUID();
                    }
                    const timestamp = Date.now();
                    const counter = this.idCounter++;
                    const random = Math.floor(Math.random() * 1000);
                    return `${timestamp}-${counter}-${random}`;
                }

                async addTransaction(transactionData) {
                    const { date, type, category, amount, description } = transactionData;
                    
                    if (!date || !type || !category || !amount || amount <= 0) {
                        throw new Error('ã™ã¹ã¦ã®å¿…é ˆé …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆé‡‘é¡ã¯1å††ä»¥ä¸Šï¼‰');
                    }

                    const transaction = {
                        id: this.generateUniqueId(),
                        date,
                        type,
                        category,
                        amount: parseFloat(amount),
                        description: description || ''
                    };

                    this.transactions.push(transaction);
                    
                    // IndexedDBã«ä¿å­˜
                    if (this.isInitialized && this.dbManager.db) {
                        try {
                            await this.dbManager.addTransaction(transaction);
                        } catch (error) {
                            console.error('IndexedDBä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                        }
                    }
                    
                    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–
                    this.invalidateSummaryCache();
                    
                    if (this.transactions.length % CONSTANTS.DEFAULTS.AUTO_BACKUP_INTERVAL === 0) {
                        this.createAutoBackup();
                    }
                    
                    this.emit('transactionAdded', transaction);
                    this.emit('dataChanged');
                    
                    return transaction;
                }

                async deleteTransaction(id) {
                    const index = this.transactions.findIndex(t => t.id === id);
                    if (index !== -1) {
                        const deleted = this.transactions.splice(index, 1)[0];
                        
                        // IndexedDBã‹ã‚‰å‰Šé™¤
                        if (this.isInitialized && this.dbManager.db) {
                            try {
                                await this.dbManager.deleteTransaction(id);
                            } catch (error) {
                                console.error('IndexedDBå‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                            }
                        }
                        
                        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–
                        this.invalidateSummaryCache();
                        
                        this.emit('transactionDeleted', deleted);
                        this.emit('dataChanged');
                        return deleted;
                    }
                    return null;
                }

                applyFilters(filters) {
                    this.filters = { ...filters };
                    
                    this.filteredTransactions = this.transactions.filter(transaction => {
                        const typeMatch = !this.filters.type || transaction.type === this.filters.type;
                        const categoryMatch = !this.filters.category || transaction.category === this.filters.category;
                        const monthMatch = !this.filters.month || transaction.date.startsWith(this.filters.month);
                        
                        return typeMatch && categoryMatch && monthMatch;
                    });

                    this.emit('filtersApplied', this.filteredTransactions);
                }

                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ã—ãŸé›†è¨ˆ
                calculateSummary() {
                    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒæœ‰åŠ¹ãªå ´åˆã¯ä½¿ç”¨
                    if (this.summaryCache && this.lastSummaryUpdate === this.transactions.length) {
                        return this.summaryCache;
                    }

                    const income = this.transactions
                        .filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.INCOME)
                        .reduce((sum, t) => sum + t.amount, 0);
                    
                    const expense = this.transactions
                        .filter(t => t.type === CONSTANTS.TRANSACTION_TYPES.EXPENSE)
                        .reduce((sum, t) => sum + t.amount, 0);
                    
                    this.summaryCache = {
                        income,
                        expense,
                        balance: income - expense
                    };
                    
                    this.lastSummaryUpdate = this.transactions.length;
                    
                    return this.summaryCache;
                }

                // æœˆåˆ¥é›†è¨ˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                getMonthlyData(months = 12, endDate = new Date()) {
                    const monthlyData = new Map();
                    
                    // æŒ‡å®šã•ã‚ŒãŸæœˆæ•°åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
                    for (let i = months - 1; i >= 0; i--) {
                        const date = new Date(endDate.getFullYear(), endDate.getMonth() - i, 1);
                        const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                        monthlyData.set(key, { income: 0, expense: 0 });
                    }
                    
                    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é›†è¨ˆ
                    this.transactions.forEach(transaction => {
                        const month = transaction.date.substring(0, 7);
                        if (monthlyData.has(month)) {
                            const data = monthlyData.get(month);
                            if (transaction.type === CONSTANTS.TRANSACTION_TYPES.INCOME) {
                                data.income += transaction.amount;
                            } else {
                                data.expense += transaction.amount;
                            }
                        }
                    });
                    
                    return monthlyData;
                }

                invalidateSummaryCache() {
                    this.summaryCache = null;
                    this.lastSummaryUpdate = null;
                }

                addCategory(type, categoryName) {
                    if (!categoryName.trim()) {
                        throw new Error('ã‚«ãƒ†ã‚´ãƒªåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                    }
                    
                    if (this.categories[type].includes(categoryName)) {
                        throw new Error('ã“ã®ã‚«ãƒ†ã‚´ãƒªã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™');
                    }
                    
                    this.categories[type].push(categoryName);
                    this.emit('categoryAdded', { type, categoryName });
                    return true;
                }

                removeCategory(type, categoryName, replacementCategory = null) {
                    const relatedTransactions = this.transactions.filter(t => 
                        t.type === type && t.category === categoryName
                    );

                    if (relatedTransactions.length > 0) {
                        if (!replacementCategory) {
                            throw new Error(`ã“ã®ã‚«ãƒ†ã‚´ãƒªã¯${relatedTransactions.length}ä»¶ã®å–å¼•ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚ä»£æ›¿ã‚«ãƒ†ã‚´ãƒªã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚`);
                        }
                        
                        relatedTransactions.forEach(t => {
                            t.category = replacementCategory;
                        });
                    }

                    this.categories[type] = this.categories[type].filter(c => c !== categoryName);
                    this.emit('categoryRemoved', { type, categoryName });
                    this.emit('dataChanged');
                    return relatedTransactions.length;
                }

                toSaveFormat() {
                    return {
                        transactions: this.transactions,
                        categories: this.categories,
                        idCounter: this.idCounter,
                        filters: this.filters
                    };
                }

                fromSaveFormat(data) {
                    if (data.transactions && Array.isArray(data.transactions)) {
                        this.transactions = data.transactions;
                    }
                    if (data.categories) {
                        this.categories = data.categories;
                    }
                    if (data.idCounter) {
                        this.idCounter = data.idCounter;
                    }
                    if (data.filters) {
                        this.filters = data.filters;
                    }
                    this.invalidateSummaryCache();
                    this.emit('dataLoaded');
                    this.emit('dataChanged');
                }

                async createAutoBackup() {
                    try {
                        const backupData = this.toSaveFormat();
                        
                        if (this.isInitialized && this.dbManager.db) {
                            await this.dbManager.createBackup(backupData);
                        } else {
                            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: localStorageã«ä¿å­˜
                            localStorage.setItem(CONSTANTS.STORAGE_KEYS.BACKUP_DATA, JSON.stringify({
                                timestamp: new Date().toISOString(),
                                version: '2.0',
                                data: backupData
                            }));
                        }
                        
                        console.log('è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆã—ã¾ã—ãŸ');
                    } catch (error) {
                        console.error('è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                    }
                }

                async saveSettings() {
                    if (this.isInitialized && this.dbManager.db) {
                        try {
                            await this.dbManager.saveSettings({
                                categories: this.categories,
                                filters: this.filters,
                                idCounter: this.idCounter
                            });
                        } catch (error) {
                            console.error('è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                        }
                    }
                }
            }

            // Debounceå®Ÿè£…
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Chart.jsç®¡ç†ã‚¯ãƒ©ã‚¹
            class ChartManager {
                constructor(dataManager) {
                    this.dataManager = dataManager;
                    this.chart = null;
                    this.currentEndDate = new Date();
                    this.currentRange = 12;
                    this.setupChart();
                    this.bindEvents();
                }

                setupChart() {
                    const ctx = document.getElementById('monthlyChart').getContext('2d');
                    
                    this.chart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'åå…¥',
                                    data: [],
                                    backgroundColor: CONSTANTS.CHART.COLORS.INCOME,
                                    borderColor: CONSTANTS.CHART.COLORS.INCOME_BORDER,
                                    borderWidth: 1
                                },
                                {
                                    label: 'æ”¯å‡º',
                                    data: [],
                                    backgroundColor: CONSTANTS.CHART.COLORS.EXPENSE,
                                    borderColor: CONSTANTS.CHART.COLORS.EXPENSE_BORDER,
                                    borderWidth: 1
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'æœˆåˆ¥åæ”¯',
                                    font: {
                                        size: 16
                                    }
                                },
                                legend: {
                                    position: 'top',
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            let label = context.dataset.label || '';
                                            if (label) {
                                                label += ': ';
                                            }
                                            label += 'Â¥' + context.parsed.y.toLocaleString();
                                            return label;
                                        }
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 200000, // æœ€å¤§å€¤ã‚’20ä¸‡å††ã«è¨­å®š
                                    ticks: {
                                        stepSize: 5000, // 5,000å††åˆ»ã¿
                                        callback: function(value) {
                                            // 5,000å††å˜ä½ã§è¡¨ç¤º
                                            if (value === 0) {
                                                return '0';
                                            } else if (value >= 10000) {
                                                // 1ä¸‡å††ä»¥ä¸Šã¯ä¸‡å††å˜ä½ã§è¡¨ç¤ºï¼ˆä¾‹: 5ä¸‡å††ã€10ä¸‡å††ã€15ä¸‡å††ï¼‰
                                                return (value / 10000) + 'ä¸‡å††';
                                            } else {
                                                // 1ä¸‡å††æœªæº€ã¯å††å˜ä½ã§è¡¨ç¤ºï¼ˆä¾‹: 5,000å††ï¼‰
                                                return value.toLocaleString() + 'å††';
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                }

                bindEvents() {
                    document.getElementById('chartPrevBtn').addEventListener('click', () => this.navigateChart(-1));
                    document.getElementById('chartNextBtn').addEventListener('click', () => this.navigateChart(1));
                    document.getElementById('chartCurrentBtn').addEventListener('click', () => this.showCurrentMonth());
                    document.getElementById('chartRange').addEventListener('change', (e) => this.changeRange(e.target.value));
                    
                    this.dataManager.on('dataChanged', () => this.updateChart());
                }

                navigateChart(direction) {
                    const months = this.currentRange === 'all' ? 12 : parseInt(this.currentRange);
                    this.currentEndDate = new Date(
                        this.currentEndDate.getFullYear(),
                        this.currentEndDate.getMonth() + (direction * months),
                        1
                    );
                    this.updateChart();
                }

                showCurrentMonth() {
                    this.currentEndDate = new Date();
                    this.updateChart();
                }

                changeRange(range) {
                    this.currentRange = range;
                    this.updateChart();
                }

                updateChart() {
                    let monthlyData;
                    let months;
                    
                    if (this.currentRange === 'all') {
                        // å…¨æœŸé–“ã®å ´åˆã¯ã€æœ€åˆã¨æœ€å¾Œã®å–å¼•ã‹ã‚‰æœŸé–“ã‚’è¨ˆç®—
                        const sortedTransactions = [...this.dataManager.transactions].sort((a, b) => 
                            new Date(a.date) - new Date(b.date)
                        );
                        
                        if (sortedTransactions.length > 0) {
                            const firstDate = new Date(sortedTransactions[0].date);
                            const lastDate = new Date(sortedTransactions[sortedTransactions.length - 1].date);
                            
                            // æœˆæ•°ã‚’è¨ˆç®—
                            months = (lastDate.getFullYear() - firstDate.getFullYear()) * 12 + 
                                    (lastDate.getMonth() - firstDate.getMonth()) + 1;
                            
                            monthlyData = this.dataManager.getMonthlyData(months, lastDate);
                        } else {
                            months = 12;
                            monthlyData = this.dataManager.getMonthlyData(months, this.currentEndDate);
                        }
                    } else {
                        months = parseInt(this.currentRange);
                        monthlyData = this.dataManager.getMonthlyData(months, this.currentEndDate);
                    }
                    
                    const labels = [];
                    const incomeData = [];
                    const expenseData = [];
                    
                    monthlyData.forEach((data, month) => {
                        const [year, monthNum] = month.split('-');
                        labels.push(`${year}å¹´${parseInt(monthNum)}æœˆ`);
                        incomeData.push(data.income);
                        expenseData.push(data.expense);
                    });
                    
                    this.chart.data.labels = labels;
                    this.chart.data.datasets[0].data = incomeData;
                    this.chart.data.datasets[1].data = expenseData;
                    this.chart.update();
                }
            }

            // ãƒ¢ãƒ¼ãƒ€ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹
            class ModalManager extends EventEmitter {
                constructor() {
                    super();
                    this.modalStack = [];
                }

                createModal() {
                    const overlay = document.createElement('div');
                    overlay.className = CONSTANTS.CSS_CLASSES.MODAL_OVERLAY;
                    overlay.setAttribute('role', 'dialog');
                    overlay.setAttribute('aria-modal', 'true');
                    
                    const content = document.createElement('div');
                    content.className = CONSTANTS.CSS_CLASSES.MODAL_CONTENT;
                    
                    overlay.appendChild(content);
                    document.body.appendChild(overlay);
                    
                    const container = document.querySelector('.container');
                    if (container) {
                        container.setAttribute('aria-hidden', 'true');
                    }
                    
                    return { overlay, content };
                }

                showModal(modal) {
                    this.modalStack.push(modal);
                    setTimeout(() => modal.classList.add(CONSTANTS.CSS_CLASSES.SHOW), 10);
                    
                    this.setupFocusTrap(modal);
                }

                closeModal(modal) {
                    modal.classList.remove(CONSTANTS.CSS_CLASSES.SHOW);
                    
                    const container = document.querySelector('.container');
                    if (container) {
                        container.removeAttribute('aria-hidden');
                    }
                    
                    if (modal.escHandler) {
                        document.removeEventListener('keydown', modal.escHandler);
                    }
                    
                    if (modal.focusTrapHandler) {
                        document.removeEventListener('keydown', modal.focusTrapHandler);
                    }
                    
                    setTimeout(() => {
                        if (modal.parentNode) {
                            document.body.removeChild(modal);
                        }
                        this.modalStack = this.modalStack.filter(m => m !== modal);
                    }, 300);
                }

                setupFocusTrap(modal) {
                    const focusableElements = modal.querySelectorAll(
                        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                    );
                    
                    if (focusableElements.length === 0) return;
                    
                    const firstFocusable = focusableElements[0];
                    const lastFocusable = focusableElements[focusableElements.length - 1];
                    
                    firstFocusable.focus();
                    
                    modal.focusTrapHandler = (e) => {
                        if (e.key !== 'Tab') return;
                        
                        if (e.shiftKey) {
                            if (document.activeElement === firstFocusable) {
                                e.preventDefault();
                                lastFocusable.focus();
                            }
                        } else {
                            if (document.activeElement === lastFocusable) {
                                e.preventDefault();
                                firstFocusable.focus();
                            }
                        }
                    };
                    
                    document.addEventListener('keydown', modal.focusTrapHandler);
                }

                async showConfirm(title, message, options = {}) {
                    return new Promise((resolve) => {
                        const modal = this.createModal();
                        
                        modal.content.innerHTML = `
                            <h2 class="modal-title">${title}</h2>
                            <p class="modal-text">${message}</p>
                            <div class="modal-buttons">
                                <button class="btn btn-secondary" data-action="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                                <button class="btn btn-primary" data-action="confirm">${options.confirmText || 'OK'}</button>
                            </div>
                        `;

                        const handleClose = (result) => {
                            this.closeModal(modal.overlay);
                            resolve(result);
                        };

                        modal.overlay.addEventListener('click', (e) => {
                            if (e.target === modal.overlay) {
                                handleClose(false);
                            }
                        });

                        modal.content.addEventListener('click', (e) => {
                            if (e.target.dataset.action === 'confirm') {
                                handleClose(true);
                            } else if (e.target.dataset.action === 'cancel') {
                                handleClose(false);
                            }
                        });

                        modal.escHandler = (e) => {
                            if (e.key === 'Escape') {
                                handleClose(false);
                            }
                        };
                        document.addEventListener('keydown', modal.escHandler);

                        this.showModal(modal.overlay);
                    });
                }
            }

            // é€šçŸ¥ç®¡ç†ã‚¯ãƒ©ã‚¹
            class NotificationManager {
                constructor() {
                    this.defaultDuration = CONSTANTS.DEFAULTS.NOTIFICATION_DURATION;
                }

                show(message, type = CONSTANTS.NOTIFICATION_TYPES.INFO, duration = this.defaultDuration) {
                    const notification = document.createElement('div');
                    notification.className = `notification ${type}`;
                    notification.setAttribute('role', 'alert');
                    
                    if (message.includes('\n')) {
                        notification.style.whiteSpace = 'pre-line';
                    }
                    notification.textContent = message;
                    
                    document.body.appendChild(notification);
                    
                    setTimeout(() => notification.classList.add(CONSTANTS.CSS_CLASSES.SHOW), 100);
                    
                    setTimeout(() => {
                        notification.classList.remove(CONSTANTS.CSS_CLASSES.SHOW);
                        setTimeout(() => {
                            if (notification.parentNode) {
                                document.body.removeChild(notification);
                            }
                        }, 300);
                    }, duration);
                }
            }

            // ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¯ãƒ©ã‚¹
            class FileHandler {
                constructor(dataManager) {
                    this.dataManager = dataManager;
                }

                exportToJSON() {
                    try {
                        const dataStr = JSON.stringify(this.dataManager.toSaveFormat(), null, 2);
                        const dataBlob = new Blob([dataStr], {type: 'application/json'});
                        
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(dataBlob);
                        link.download = `å®¶è¨ˆç°¿ãƒ‡ãƒ¼ã‚¿_${new Date().toISOString().split('T')[0]}.json`;
                        link.click();
                        
                        return { success: true };
                    } catch (error) {
                        console.error('JSON export error:', error);
                        return { success: false, error };
                    }
                }

                async importFromJSON(file) {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const importedData = JSON.parse(e.target.result);
                                resolve({ success: true, data: importedData });
                            } catch (error) {
                                console.error('JSON import error:', error);
                                resolve({ success: false, error });
                            }
                        };
                        reader.onerror = () => {
                            resolve({ success: false, error: new Error('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ') });
                        };
                        reader.readAsText(file);
                    });
                }

                exportToExcel() {
                    if (this.dataManager.transactions.length === 0) {
                        return { success: false, error: new Error('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“') };
                    }

                    try {
                        const excelData = this.dataManager.transactions.map(transaction => ({
                            'æ—¥ä»˜': transaction.date,
                            'ç¨®é¡': transaction.type === CONSTANTS.TRANSACTION_TYPES.INCOME ? 'åå…¥' : 'æ”¯å‡º',
                            'ã‚«ãƒ†ã‚´ãƒª': transaction.category,
                            'èª¬æ˜': transaction.description,
                            'é‡‘é¡': transaction.amount
                        }));

                        const summary = this.dataManager.calculateSummary();

                        excelData.push({});
                        excelData.push({
                            'æ—¥ä»˜': 'ã‚µãƒãƒªãƒ¼',
                            'ç¨®é¡': '',
                            'ã‚«ãƒ†ã‚´ãƒª': '',
                            'èª¬æ˜': '',
                            'é‡‘é¡': ''
                        });
                        excelData.push({
                            'æ—¥ä»˜': '',
                            'ç¨®é¡': '',
                            'ã‚«ãƒ†ã‚´ãƒª': 'ç·åå…¥',
                            'èª¬æ˜': '',
                            'é‡‘é¡': summary.income
                        });
                        excelData.push({
                            'æ—¥ä»˜': '',
                            'ç¨®é¡': '',
                            'ã‚«ãƒ†ã‚´ãƒª': 'ç·æ”¯å‡º',
                            'èª¬æ˜': '',
                            'é‡‘é¡': summary.expense
                        });
                        excelData.push({
                            'æ—¥ä»˜': '',
                            'ç¨®é¡': '',
                            'ã‚«ãƒ†ã‚´ãƒª': 'æ®‹é«˜',
                            'èª¬æ˜': '',
                            'é‡‘é¡': summary.balance
                        });

                        const ws = XLSX.utils.json_to_sheet(excelData);
                        
                        ws['!cols'] = [
                            { width: 12 },
                            { width: 8 },
                            { width: 15 },
                            { width: 30 },
                            { width: 12 }
                        ];

                        const wb = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(wb, ws, 'å®¶è¨ˆç°¿ãƒ‡ãƒ¼ã‚¿');

                        const fileName = `å®¶è¨ˆç°¿ãƒ‡ãƒ¼ã‚¿_${new Date().toISOString().split('T')[0]}.xlsx`;
                        
                        XLSX.writeFile(wb, fileName);
                        return { success: true };
                    } catch (error) {
                        console.error('Excel export error:', error);
                        return { success: false, error };
                    }
                }

                async importFromExcel(file) {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const data = new Uint8Array(e.target.result);
                                const workbook = XLSX.read(data, { type: 'array' });
                                
                                const firstSheetName = workbook.SheetNames[0];
                                const worksheet = workbook.Sheets[firstSheetName];
                                
                                const jsonData = XLSX.utils.sheet_to_json(worksheet);
                                
                                resolve({ success: true, data: jsonData });
                            } catch (error) {
                                console.error('Excel import error:', error);
                                resolve({ success: false, error });
                            }
                        };
                        reader.onerror = () => {
                            resolve({ success: false, error: new Error('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ') });
                        };
                        reader.readAsArrayBuffer(file);
                    });
                }
            }

            // UIç®¡ç†ã‚¯ãƒ©ã‚¹ï¼ˆIndexedDBå¯¾å¿œç‰ˆï¼‰
            class UIManager {
                constructor(dataManager) {
                    this.dataManager = dataManager;
                    this.modalManager = new ModalManager();
                    this.notificationManager = new NotificationManager();
                    this.fileHandler = new FileHandler(dataManager);
                    this.chartManager = null; // å¾Œã§åˆæœŸåŒ–
                    
                    // Debounceå‡¦ç†ç”¨
                    this.debouncedSaveSettings = debounce(() => {
                        this.dataManager.saveSettings();
                    }, CONSTANTS.DEFAULTS.DEBOUNCE_DELAY);
                    
                    this.setupEventListeners();
                    this.bindDataEvents();
                }

                setupEventListeners() {
                    // ãƒ•ã‚©ãƒ¼ãƒ ã‚¤ãƒ™ãƒ³ãƒˆ
                    document.getElementById('transactionForm').addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleTransactionSubmit();
                    });

                    document.getElementById('type').addEventListener('change', () => {
                        this.updateCategoryOptions();
                    });

                    // ãƒ•ã‚£ãƒ«ã‚¿ã‚¤ãƒ™ãƒ³ãƒˆ
                    document.getElementById('filterType').addEventListener('change', () => this.handleFilterChange());
                    document.getElementById('filterCategory').addEventListener('change', () => this.handleFilterChange());
                    document.getElementById('filterMonth').addEventListener('input', () => this.handleFilterChange());

                    // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
                    document.getElementById('exportExcelBtn').addEventListener('click', () => this.exportToExcel());
                    document.getElementById('importExcelBtn').addEventListener('click', () => document.getElementById('excelFileInput').click());
                    document.getElementById('exportJsonBtn').addEventListener('click', () => this.exportData());
                    document.getElementById('importJsonBtn').addEventListener('click', () => document.getElementById('fileInput').click());
                    document.getElementById('clearDataBtn').addEventListener('click', () => this.clearAllData());
                    document.getElementById('storageInfoBtn').addEventListener('click', () => this.showStorageInfo());
                    document.getElementById('restoreBackupBtn').addEventListener('click', () => this.restoreFromBackup());
                    document.getElementById('categoryManagerBtn').addEventListener('click', () => this.showCategoryManager());

                    // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ
                    document.getElementById('fileInput').addEventListener('change', (e) => this.importData(e));
                    document.getElementById('excelFileInput').addEventListener('change', (e) => this.importFromExcel(e));

                    // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®è¨­å®šä¿å­˜
                    window.addEventListener('beforeunload', () => {
                        if (this.dataManager.isInitialized) {
                            this.dataManager.saveSettings();
                        }
                    });
                }

                bindDataEvents() {
                    this.dataManager.on('dataChanged', () => {
                        this.updateSummary();
                        this.debouncedSaveSettings();
                    });

                    this.dataManager.on('transactionAdded', () => {
                        this.handleFilterChange();
                        this.clearForm();
                        this.notificationManager.show('å–å¼•ã‚’è¿½åŠ ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                    });

                    this.dataManager.on('transactionDeleted', () => {
                        this.handleFilterChange();
                        this.notificationManager.show('å–å¼•ã‚’å‰Šé™¤ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                    });

                    this.dataManager.on('filtersApplied', (filteredTransactions) => {
                        this.displayTransactions(filteredTransactions);
                    });

                    this.dataManager.on('categoryAdded', ({ categoryName }) => {
                        this.updateCategoryOptions();
                        this.updateFilterCategoryOptions();
                        this.notificationManager.show(`ã‚«ãƒ†ã‚´ãƒªã€Œ${categoryName}ã€ã‚’è¿½åŠ ã—ã¾ã—ãŸ`, CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                    });

                    this.dataManager.on('categoryRemoved', ({ categoryName }) => {
                        this.updateCategoryOptions();
                        this.updateFilterCategoryOptions();
                        this.notificationManager.show(`ã‚«ãƒ†ã‚´ãƒªã€Œ${categoryName}ã€ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                    });

                    this.dataManager.on('dataLoaded', () => {
                        this.updateCategoryOptions();
                        this.updateFilterCategoryOptions();
                        this.updateSummary();
                        this.handleFilterChange();
                        
                        // ãƒãƒ£ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–
                        if (!this.chartManager) {
                            this.chartManager = new ChartManager(this.dataManager);
                        }
                    });
                }

                async handleTransactionSubmit() {
                    const date = document.getElementById('date').value;
                    const type = document.getElementById('type').value;
                    const category = document.getElementById('category').value;
                    const amount = parseFloat(document.getElementById('amount').value);
                    const description = document.getElementById('description').value;

                    try {
                        await this.dataManager.addTransaction({ date, type, category, amount, description });
                    } catch (error) {
                        this.notificationManager.show(error.message, CONSTANTS.NOTIFICATION_TYPES.ERROR);
                    }
                }

                handleFilterChange() {
                    const filters = {
                        type: document.getElementById('filterType').value,
                        category: document.getElementById('filterCategory').value,
                        month: document.getElementById('filterMonth').value
                    };
                    this.dataManager.applyFilters(filters);
                }

                updateCategoryOptions() {
                    const type = document.getElementById('type').value;
                    const categorySelect = document.getElementById('category');
                    
                    categorySelect.innerHTML = '<option value="">é¸æŠã—ã¦ãã ã•ã„</option>';
                    
                    if (type && this.dataManager.categories[type]) {
                        this.dataManager.categories[type].forEach(category => {
                            const option = document.createElement('option');
                            option.value = category;
                            option.textContent = category;
                            categorySelect.appendChild(option);
                        });
                    }
                }

                updateFilterCategoryOptions() {
                    const filterCategorySelect = document.getElementById('filterCategory');
                    const allCategories = [
                        ...this.dataManager.categories[CONSTANTS.TRANSACTION_TYPES.INCOME], 
                        ...this.dataManager.categories[CONSTANTS.TRANSACTION_TYPES.EXPENSE]
                    ];
                    
                    filterCategorySelect.innerHTML = '<option value="">ã™ã¹ã¦</option>';
                    
                    allCategories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category;
                        option.textContent = category;
                        filterCategorySelect.appendChild(option);
                    });
                }

                updateSummary() {
                    const summary = this.dataManager.calculateSummary();
                    document.getElementById('totalIncome').textContent = this.formatCurrency(summary.income);
                    document.getElementById('totalExpense').textContent = this.formatCurrency(summary.expense);
                    document.getElementById('balance').textContent = this.formatCurrency(summary.balance);
                }

                displayTransactions(transactions) {
                    const tbody = document.getElementById('transactionsBody');
                    const emptyState = document.getElementById('emptyState');
                    
                    if (transactions.length === 0) {
                        tbody.innerHTML = '';
                        emptyState.style.display = 'block';
                        return;
                    }
                    
                    emptyState.style.display = 'none';
                    
                    const fragment = document.createDocumentFragment();
                    
                    const sortedTransactions = [...transactions].sort((a, b) => 
                        new Date(b.date) - new Date(a.date)
                    );
                    
                    sortedTransactions.forEach(transaction => {
                        const tr = document.createElement('tr');
                        
                        const tdDate = document.createElement('td');
                        tdDate.textContent = this.formatDate(transaction.date);
                        tr.appendChild(tdDate);
                        
                        const tdType = document.createElement('td');
                        tdType.textContent = transaction.type === CONSTANTS.TRANSACTION_TYPES.INCOME ? 'åå…¥' : 'æ”¯å‡º';
                        tr.appendChild(tdType);
                        
                        const tdCategory = document.createElement('td');
                        tdCategory.textContent = transaction.category;
                        tr.appendChild(tdCategory);
                        
                        const tdDescription = document.createElement('td');
                        tdDescription.textContent = transaction.description;
                        tr.appendChild(tdDescription);
                        
                        const tdAmount = document.createElement('td');
                        tdAmount.className = transaction.type === CONSTANTS.TRANSACTION_TYPES.INCOME ? 'amount-positive' : 'amount-negative';
                        tdAmount.textContent = `${transaction.type === CONSTANTS.TRANSACTION_TYPES.INCOME ? '+' : '-'}${this.formatCurrency(transaction.amount)}`;
                        tr.appendChild(tdAmount);
                        
                        const tdAction = document.createElement('td');
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-btn';
                        deleteBtn.textContent = 'å‰Šé™¤';
                        deleteBtn.setAttribute('aria-label', `${this.formatDate(transaction.date)}ã®å–å¼•ã‚’å‰Šé™¤`);
                        deleteBtn.addEventListener('click', () => this.deleteTransactionWithConfirm(transaction.id));
                        tdAction.appendChild(deleteBtn);
                        tr.appendChild(tdAction);
                        
                        fragment.appendChild(tr);
                    });
                    
                    tbody.innerHTML = '';
                    tbody.appendChild(fragment);
                }

                formatCurrency(amount) {
                    return 'Â¥' + amount.toLocaleString();
                }

                formatDate(dateString) {
                    const date = new Date(dateString);
                    return date.toLocaleDateString('ja-JP');
                }

                clearForm() {
                    document.getElementById('transactionForm').reset();
                    document.getElementById('date').value = new Date().toISOString().split('T')[0];
                    this.updateCategoryOptions();
                }

                async deleteTransactionWithConfirm(id) {
                    const confirmed = await this.modalManager.showConfirm(
                        'å–å¼•ã‚’å‰Šé™¤',
                        'ã“ã®å–å¼•ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ',
                        { confirmText: 'å‰Šé™¤' }
                    );
                    
                    if (confirmed) {
                        await this.dataManager.deleteTransaction(id);
                    }
                }

                async clearAllData() {
                    const confirmed = await this.modalManager.showConfirm(
                        'ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤',
                        'ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚',
                        { confirmText: 'å‰Šé™¤' }
                    );
                    
                    if (confirmed) {
                        this.dataManager.transactions = [];
                        if (this.dataManager.isInitialized && this.dataManager.dbManager.db) {
                            await this.dataManager.dbManager.clearTransactions();
                        }
                        this.dataManager.invalidateSummaryCache();
                        this.dataManager.emit('dataChanged');
                        this.handleFilterChange();
                        this.notificationManager.show('ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                    }
                }

                exportToExcel() {
                    const result = this.fileHandler.exportToExcel();
                    if (result.success) {
                        this.notificationManager.show('Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                    } else {
                        this.notificationManager.show(result.error.message, CONSTANTS.NOTIFICATION_TYPES.WARNING);
                    }
                }

                async importFromExcel(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    try {
                        const importMode = await this.showImportOptions();
                        if (!importMode) return;

                        this.showLoading('Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...');

                        const result = await this.fileHandler.importFromExcel(file);
                        
                        if (!result.success) {
                            this.hideLoading();
                            this.notificationManager.show('Excelãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.ERROR);
                            return;
                        }

                        const jsonData = result.data;

                        if (jsonData.length === 0) {
                            this.hideLoading();
                            this.notificationManager.show('Excelãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“', CONSTANTS.NOTIFICATION_TYPES.WARNING);
                            return;
                        }

                        const firstRow = jsonData[0];
                        const requiredColumns = ['æ—¥ä»˜', 'ç¨®é¡', 'ã‚«ãƒ†ã‚´ãƒª', 'é‡‘é¡'];
                        const missingColumns = requiredColumns.filter(col => !(col in firstRow));
                        
                        if (missingColumns.length > 0) {
                            this.hideLoading();
                            await this.modalManager.showConfirm(
                                'ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚¨ãƒ©ãƒ¼',
                                `å¿…è¦ãªåˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${missingColumns.join(', ')}\n\nå¿…è¦ãªåˆ—: æ—¥ä»˜ã€ç¨®é¡ã€ã‚«ãƒ†ã‚´ãƒªã€èª¬æ˜ï¼ˆä»»æ„ï¼‰ã€é‡‘é¡`,
                                { confirmText: 'OK' }
                            );
                            return;
                        }

                        this.showLoading('ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ã—ã¦ã„ã¾ã™...');

                        const importedTransactions = [];
                        const allCategories = [
                            ...this.dataManager.categories[CONSTANTS.TRANSACTION_TYPES.INCOME], 
                            ...this.dataManager.categories[CONSTANTS.TRANSACTION_TYPES.EXPENSE]
                        ];
                        const invalidRows = [];
                        
                        for (let i = 0; i < jsonData.length; i++) {
                            const row = jsonData[i];
                            if (!row['æ—¥ä»˜'] || row['æ—¥ä»˜'] === 'ã‚µãƒãƒªãƒ¼' || !row['ç¨®é¡'] || !row['é‡‘é¡']) {
                                continue;
                            }

                            const transaction = {
                                date: DateParser.formatDateForInput(row['æ—¥ä»˜']),
                                type: row['ç¨®é¡'] === 'åå…¥' ? CONSTANTS.TRANSACTION_TYPES.INCOME : CONSTANTS.TRANSACTION_TYPES.EXPENSE,
                                category: row['ã‚«ãƒ†ã‚´ãƒª'] || '',
                                description: row['èª¬æ˜'] || '',
                                amount: parseFloat(row['é‡‘é¡']) || 0
                            };

                            if (!transaction.date) {
                                invalidRows.push(`è¡Œ${i + 2}: æ—¥ä»˜å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“`);
                                continue;
                            }
                            
                            if (transaction.type !== CONSTANTS.TRANSACTION_TYPES.INCOME && transaction.type !== CONSTANTS.TRANSACTION_TYPES.EXPENSE) {
                                invalidRows.push(`è¡Œ${i + 2}: ç¨®é¡ã¯ã€Œåå…¥ã€ã¾ãŸã¯ã€Œæ”¯å‡ºã€ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`);
                                continue;
                            }
                            
                            if (transaction.amount <= 0) {
                                invalidRows.push(`è¡Œ${i + 2}: é‡‘é¡ã¯1å††ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`);
                                continue;
                            }

                            if (transaction.category && !allCategories.includes(transaction.category)) {
                                this.hideLoading();
                                const shouldAdd = await this.modalManager.showConfirm(
                                    'ã‚«ãƒ†ã‚´ãƒªã‚’è¿½åŠ ',
                                    `æ–°ã—ã„ã‚«ãƒ†ã‚´ãƒªã€Œ${transaction.category}ã€ã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ`,
                                    { confirmText: 'è¿½åŠ ' }
                                );
                                this.showLoading('ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ã—ã¦ã„ã¾ã™...');
                                
                                if (shouldAdd) {
                                    this.dataManager.categories[transaction.type].push(transaction.category);
                                    allCategories.push(transaction.category);
                                } else {
                                    transaction.category = transaction.type === CONSTANTS.TRANSACTION_TYPES.INCOME ? 'ãã®ä»–åå…¥' : 'ãã®ä»–æ”¯å‡º';
                                }
                            }
                            
                            if (transaction.category) {
                                importedTransactions.push(transaction);
                            }
                        }

                        this.hideLoading();

                        if (invalidRows.length > 0) {
                            const errorMessage = `ä»¥ä¸‹ã®è¡Œã«ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚Šã¾ã—ãŸ:\n\n${invalidRows.slice(0, 5).join('\n')}${invalidRows.length > 5 ? `\n...ä»–${invalidRows.length - 5}ä»¶ã®ã‚¨ãƒ©ãƒ¼` : ''}`;
                            await this.modalManager.showConfirm(
                                'ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼',
                                errorMessage,
                                { confirmText: 'OK' }
                            );
                        }

                        if (importedTransactions.length === 0) {
                            this.notificationManager.show('ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.WARNING);
                            return;
                        }

                        if (importMode === 'add') {
                            for (const t of importedTransactions) {
                                await this.dataManager.addTransaction(t);
                            }
                            this.notificationManager.show(`${importedTransactions.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¾ã—ãŸ`, CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                        } else {
                            await this.dataManager.createAutoBackup();
                            this.dataManager.transactions = [];
                            if (this.dataManager.isInitialized && this.dataManager.dbManager.db) {
                                await this.dataManager.dbManager.clearTransactions();
                            }
                            for (const t of importedTransactions) {
                                await this.dataManager.addTransaction(t);
                            }
                            this.notificationManager.show(`${importedTransactions.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`, CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                        }

                    } catch (error) {
                        this.hideLoading();
                        console.error('Import error:', error);
                        this.notificationManager.show('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.ERROR);
                    }
                }

                exportData() {
                    const result = this.fileHandler.exportToJSON();
                    if (result.success) {
                        this.notificationManager.show('JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                    } else {
                        this.notificationManager.show('JSONã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.ERROR);
                    }
                }

                async importData(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    try {
                        const importMode = await this.showImportOptions();
                        if (!importMode) return;

                        const result = await this.fileHandler.importFromJSON(file);
                        
                        if (!result.success) {
                            this.notificationManager.show('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.ERROR);
                            return;
                        }

                        const importedData = result.data;
                        
                        if (Array.isArray(importedData)) {
                            const validTransactions = importedData.filter(t => 
                                t.date && t.type && t.category && t.amount > 0
                            );
                            
                            if (importMode === 'add') {
                                for (const t of validTransactions) {
                                    await this.dataManager.addTransaction(t);
                                }
                                this.notificationManager.show(`${validTransactions.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¾ã—ãŸ`, CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                            } else {
                                await this.dataManager.createAutoBackup();
                                this.dataManager.transactions = [];
                                if (this.dataManager.isInitialized && this.dataManager.dbManager.db) {
                                    await this.dataManager.dbManager.clearTransactions();
                                }
                                for (const t of validTransactions) {
                                    await this.dataManager.addTransaction(t);
                                }
                                this.notificationManager.show('ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                            }
                            
                        } else if (importedData.transactions || importedData.data) {
                            const sourceData = importedData.data || importedData;
                            
                            if (importMode === 'add') {
                                if (sourceData.transactions) {
                                    for (const t of sourceData.transactions) {
                                        await this.dataManager.addTransaction(t);
                                    }
                                }
                                
                                if (sourceData.categories) {
                                    Object.keys(sourceData.categories).forEach(type => {
                                        if (this.dataManager.categories[type]) {
                                            sourceData.categories[type].forEach(cat => {
                                                if (!this.dataManager.categories[type].includes(cat)) {
                                                    this.dataManager.categories[type].push(cat);
                                                }
                                            });
                                        }
                                    });
                                }
                                
                                this.notificationManager.show(`${sourceData.transactions?.length || 0}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¾ã—ãŸ`, CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                            } else {
                                await this.dataManager.createAutoBackup();
                                this.dataManager.fromSaveFormat(sourceData);
                                this.notificationManager.show('ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                            }
                        } else {
                            this.notificationManager.show('ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™', CONSTANTS.NOTIFICATION_TYPES.ERROR);
                            return;
                        }
                        
                        setTimeout(() => {
                            document.getElementById('filterType').value = this.dataManager.filters.type || '';
                            document.getElementById('filterCategory').value = this.dataManager.filters.category || '';
                            document.getElementById('filterMonth').value = this.dataManager.filters.month || '';
                        }, 100);
                        
                    } catch (error) {
                        console.error('Import error:', error);
                        this.notificationManager.show('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.ERROR);
                    }
                }

                showCategoryManager() {
                    const modal = this.modalManager.createModal();
                    const categoryManagerUI = new CategoryManagerUI(this.dataManager, modal, this);
                    categoryManagerUI.render();
                    this.modalManager.showModal(modal.overlay);
                }

                async showStorageInfo() {
                    try {
                        const dataSize = JSON.stringify(this.dataManager.transactions).length;
                        const totalRecords = this.dataManager.transactions.length;
                        
                        let storageInfo = '';
                        
                        if (this.dataManager.isInitialized && this.dataManager.dbManager.db) {
                            // IndexedDBã®ä½¿ç”¨çŠ¶æ³
                            if ('storage' in navigator && 'estimate' in navigator.storage) {
                                const estimate = await navigator.storage.estimate();
                                const usage = estimate.usage || 0;
                                const quota = estimate.quota || 0;
                                storageInfo = `
                                    <p><span aria-hidden="true">ğŸ’¾</span> <strong>IndexedDBä½¿ç”¨é‡:</strong> ${(usage / 1024 / 1024).toFixed(2)} MB / ${(quota / 1024 / 1024 / 1024).toFixed(2)} GB</p>
                                    <p><span aria-hidden="true">ğŸ“Š</span> <strong>ä½¿ç”¨ç‡:</strong> ${((usage / quota) * 100).toFixed(2)}%</p>
                                `;
                            } else {
                                storageInfo = '<p><span aria-hidden="true">ğŸ’¾</span> <strong>ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸:</strong> IndexedDBä½¿ç”¨ä¸­</p>';
                            }
                        } else {
                            // localStorageã®ä½¿ç”¨çŠ¶æ³
                            let totalSize = 0;
                            for (let key in localStorage) {
                                if (localStorage.hasOwnProperty(key)) {
                                    totalSize += localStorage[key].length;
                                }
                            }
                            storageInfo = `<p><span aria-hidden="true">ğŸ’¾</span> <strong>localStorageä½¿ç”¨é‡:</strong> ${(totalSize / 1024).toFixed(2)} KB</p>`;
                        }
                        
                        const modal = this.modalManager.createModal();
                        modal.content.innerHTML = `
                            <h2 class="modal-title"><span aria-hidden="true">ğŸ’¾</span> ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±</h2>
                            <div class="info-line">
                                <p><span aria-hidden="true">ğŸ—ƒï¸</span> <strong>å–å¼•ä»¶æ•°:</strong> ${totalRecords}ä»¶</p>
                                <p><span aria-hidden="true">ğŸ“¦</span> <strong>ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º:</strong> ${(dataSize / 1024).toFixed(2)} KB</p>
                                ${storageInfo}
                                <p><span aria-hidden="true">ğŸ”„</span> <strong>æœ€çµ‚æ›´æ–°:</strong> ${new Date().toLocaleString('ja-JP')}</p>
                                <p class="${totalRecords > 0 ? 'status-success' : 'status-warning'}">
                                    ${totalRecords > 0 ? '<span aria-hidden="true">âœ…</span> ãƒ‡ãƒ¼ã‚¿ã¯è‡ªå‹•ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™' : '<span aria-hidden="true">ğŸ“</span> ã¾ã ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“'}
                                </p>
                            </div>
                            <div class="modal-buttons">
                                <button class="btn btn-primary" data-action="close">é–‰ã˜ã‚‹</button>
                            </div>
                        `;
                        
                        modal.content.addEventListener('click', (e) => {
                            if (e.target.dataset.action === 'close') {
                                this.modalManager.closeModal(modal.overlay);
                            }
                        });
                        
                        modal.escHandler = (e) => {
                            if (e.key === 'Escape') {
                                this.modalManager.closeModal(modal.overlay);
                            }
                        };
                        document.addEventListener('keydown', modal.escHandler);
                        
                        this.modalManager.showModal(modal.overlay);
                    } catch (error) {
                        this.notificationManager.show('ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.ERROR);
                    }
                }

                async restoreFromBackup() {
                    try {
                        let backup = null;
                        
                        if (this.dataManager.isInitialized && this.dataManager.dbManager.db) {
                            // IndexedDBã‹ã‚‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å–å¾—
                            backup = await this.dataManager.dbManager.getLatestBackup();
                        } else {
                            // localStorageã‹ã‚‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å–å¾—
                            const backupData = localStorage.getItem(CONSTANTS.STORAGE_KEYS.BACKUP_DATA);
                            if (backupData) {
                                backup = JSON.parse(backupData);
                            }
                        }
                        
                        if (!backup || !backup.data) {
                            this.notificationManager.show('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', CONSTANTS.NOTIFICATION_TYPES.WARNING);
                            return;
                        }
                        
                        const backupDate = new Date(backup.timestamp).toLocaleString('ja-JP');
                        const transactions = backup.data.transactions || [];
                        
                        const confirmed = await this.modalManager.showConfirm(
                            'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ã®å¾©å…ƒ',
                            `ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ\n\nãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ—¥æ™‚: ${backupDate}\nä»¶æ•°: ${transactions.length}ä»¶\n\nç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚`,
                            { confirmText: 'å¾©å…ƒ' }
                        );
                        
                        if (confirmed) {
                            this.dataManager.fromSaveFormat(backup.data);
                            if (this.dataManager.isInitialized && this.dataManager.dbManager.db) {
                                // IndexedDBã«ä¿å­˜
                                await this.dataManager.dbManager.clearTransactions();
                                for (const t of this.dataManager.transactions) {
                                    await this.dataManager.dbManager.addTransaction(t);
                                }
                                await this.dataManager.saveSettings();
                            }
                            this.notificationManager.show('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.SUCCESS);
                        }
                    } catch (error) {
                        console.error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ã®å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                        this.notificationManager.show('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ã®å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸ', CONSTANTS.NOTIFICATION_TYPES.ERROR);
                    }
                }

                async showImportOptions() {
                    return new Promise((resolve) => {
                        const modal = this.modalManager.createModal();
                        
                        modal.content.innerHTML = `
                            <h2 class="modal-title"><span aria-hidden="true">ğŸ“¥</span> ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–¹æ³•ã‚’é¸æŠ</h2>
                            <div class="radio-group">
                                <label class="radio-option selected" data-mode="add">
                                    <input type="radio" name="importMode" value="add" checked>
                                    <div>
                                        <strong>æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ </strong>
                                        <div style="font-size: 14px; color: #6c757d; margin-top: 5px;">
                                            ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¦ã€æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¾ã™
                                        </div>
                                    </div>
                                </label>
                                <label class="radio-option" data-mode="replace">
                                    <input type="radio" name="importMode" value="replace">
                                    <div>
                                        <strong>æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ä¸Šæ›¸ã</strong>
                                        <div style="font-size: 14px; color: #6c757d; margin-top: 5px;">
                                            ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ã€æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã«ç½®ãæ›ãˆã¾ã™
                                        </div>
                                    </div>
                                </label>
                            </div>
                            <div class="modal-buttons">
                                <button class="btn btn-secondary" data-action="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                                <button class="btn btn-primary" data-action="confirm">å®Ÿè¡Œ</button>
                            </div>
                        `;

                        const handleClose = (result) => {
                            this.modalManager.closeModal(modal.overlay);
                            resolve(result);
                        };

                        modal.content.addEventListener('click', (e) => {
                            if (e.target.closest('.radio-option')) {
                                const option = e.target.closest('.radio-option');
                                const radio = option.querySelector('input[type="radio"]');
                                
                                modal.content.querySelectorAll('.radio-option').forEach(opt => {
                                    opt.classList.remove('selected');
                                    opt.querySelector('input').checked = false;
                                });
                                
                                option.classList.add('selected');
                                radio.checked = true;
                            }
                            
                            if (e.target.dataset.action === 'confirm') {
                                const selectedMode = modal.content.querySelector('input[name="importMode"]:checked').value;
                                handleClose(selectedMode);
                            } else if (e.target.dataset.action === 'cancel') {
                                handleClose(null);
                            }
                        });

                        modal.overlay.addEventListener('click', (e) => {
                            if (e.target === modal.overlay) {
                                handleClose(null);
                            }
                        });

                        modal.escHandler = (e) => {
                            if (e.key === 'Escape') {
                                handleClose(null);
                            }
                        };
                        document.addEventListener('keydown', modal.escHandler);

                        this.modalManager.showModal(modal.overlay);
                    });
                }

                showLoading(message = 'å‡¦ç†ä¸­...') {
                    const existing = document.querySelector(`.${CONSTANTS.CSS_CLASSES.LOADING_SPINNER}`);
                    if (existing) {
                        existing.remove();
                    }

                    const loadingDiv = document.createElement('div');
                    loadingDiv.className = CONSTANTS.CSS_CLASSES.LOADING_SPINNER;
                    loadingDiv.setAttribute('role', 'status');
                    loadingDiv.setAttribute('aria-live', 'polite');
                    loadingDiv.innerHTML = `
                        <div class="spinner"></div>
                        <div>${message}</div>
                        <span class="sr-only">${message}</span>
                    `;
                    
                    document.body.appendChild(loadingDiv);
                    return loadingDiv;
                }

                hideLoading() {
                    const loading = document.querySelector(`.${CONSTANTS.CSS_CLASSES.LOADING_SPINNER}`);
                    if (loading) {
                        loading.remove();
                    }
                }
            }

            // ã‚«ãƒ†ã‚´ãƒªç®¡ç†UIå°‚ç”¨ã‚¯ãƒ©ã‚¹
            class CategoryManagerUI {
                constructor(dataManager, modal, uiManager) {
                    this.dataManager = dataManager;
                    this.modal = modal;
                    this.uiManager = uiManager;
                }

                render() {
                    this.modal.content.innerHTML = `
                        <h2 class="modal-title"><span aria-hidden="true">âš™ï¸</span> ã‚«ãƒ†ã‚´ãƒªç®¡ç†</h2>
                        
                        <div class="modal-section">
                            <h3><span aria-hidden="true">ğŸ’°</span> åå…¥ã‚«ãƒ†ã‚´ãƒª</h3>
                            <div id="incomeCategories"></div>
                            <div class="form-inline">
                                <input type="text" id="newIncomeCategory" placeholder="æ–°ã—ã„åå…¥ã‚«ãƒ†ã‚´ãƒª">
                                <button class="btn btn-success" data-action="add-income">è¿½åŠ </button>
                            </div>
                        </div>
                        
                        <div class="modal-section expense">
                            <h3><span aria-hidden="true">ğŸ’¸</span> æ”¯å‡ºã‚«ãƒ†ã‚´ãƒª</h3>
                            <div id="expenseCategories"></div>
                            <div class="form-inline">
                                <input type="text" id="newExpenseCategory" placeholder="æ–°ã—ã„æ”¯å‡ºã‚«ãƒ†ã‚´ãƒª">
                                <button class="btn btn-warning" data-action="add-expense">è¿½åŠ </button>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button class="btn btn-primary" data-action="close">å®Œäº†</button>
                        </div>
                    `;

                    this.setupEventListeners();
                    this.updateCategoryList();
                }

                setupEventListeners() {
                    this.modal.content.addEventListener('click', async (e) => {
                        const action = e.target.dataset.action;
                        
                        if (action === 'add-income') {
                            await this.handleAddCategory(CONSTANTS.TRANSACTION_TYPES.INCOME);
                        } else if (action === 'add-expense') {
                            await this.handleAddCategory(CONSTANTS.TRANSACTION_TYPES.EXPENSE);
                        } else if (action === 'close') {
                            this.close();
                        }
                    });

                    this.modal.content.addEventListener('keypress', async (e) => {
                        if (e.key === 'Enter') {
                            if (e.target.id === 'newIncomeCategory') {
                                await this.handleAddCategory(CONSTANTS.TRANSACTION_TYPES.INCOME);
                            } else if (e.target.id === 'newExpenseCategory') {
                                await this.handleAddCategory(CONSTANTS.TRANSACTION_TYPES.EXPENSE);
                            }
                        }
                    });

                    this.modal.overlay.addEventListener('click', (e) => {
                        if (e.target === this.modal.overlay) {
                            this.close();
                        }
                    });

                    this.modal.escHandler = (e) => {
                        if (e.key === 'Escape') {
                            this.close();
                        }
                    };
                    document.addEventListener('keydown', this.modal.escHandler);
                }

                updateCategoryList() {
                    const incomeDiv = document.getElementById('incomeCategories');
                    const expenseDiv = document.getElementById('expenseCategories');
                    
                    if (incomeDiv) {
                        incomeDiv.innerHTML = '';
                        this.dataManager.categories[CONSTANTS.TRANSACTION_TYPES.INCOME].forEach(cat => {
                            const element = this.createCategoryElement(CONSTANTS.TRANSACTION_TYPES.INCOME, cat);
                            incomeDiv.appendChild(element);
                        });
                    }
                    
                    if (expenseDiv) {
                        expenseDiv.innerHTML = '';
                        this.dataManager.categories[CONSTANTS.TRANSACTION_TYPES.EXPENSE].forEach(cat => {
                            const element = this.createCategoryElement(CONSTANTS.TRANSACTION_TYPES.EXPENSE, cat);
                            expenseDiv.appendChild(element);
                        });
                    }
                }

                createCategoryElement(type, category) {
                    const span = document.createElement('span');
                    span.className = `category-item ${type}`;
                    
                    const textNode = document.createTextNode(category);
                    span.appendChild(textNode);
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'category-remove';
                    removeBtn.textContent = 'Ã—';
                    removeBtn.title = 'å‰Šé™¤';
                    removeBtn.setAttribute('aria-label', `${category}ã‚’å‰Šé™¤`);
                    removeBtn.addEventListener('click', () => this.handleRemoveCategory(type, category));
                    
                    span.appendChild(removeBtn);
                    return span;
                }

                async handleAddCategory(type) {
                    const input = document.getElementById(type === CONSTANTS.TRANSACTION_TYPES.INCOME ? 'newIncomeCategory' : 'newExpenseCategory');
                    const newCategory = input.value.trim();
                    
                    try {
                        this.dataManager.addCategory(type, newCategory);
                        input.value = '';
                        this.updateCategoryList();
                    } catch (error) {
                        this.uiManager.notificationManager.show(error.message, CONSTANTS.NOTIFICATION_TYPES.ERROR);
                    }
                }

                async handleRemoveCategory(type, category) {
                    const relatedTransactions = this.dataManager.transactions.filter(t => 
                        t.type === type && t.category === category
                    );

                    if (relatedTransactions.length > 0) {
                        const replacementCategory = await this.showCategoryReplacementModal(type, category, relatedTransactions.length);
                        if (!replacementCategory) return;

                        try {
                            const count = this.dataManager.removeCategory(type, category, replacementCategory);
                            this.updateCategoryList();
                            this.uiManager.notificationManager.show(
                                `ã‚«ãƒ†ã‚´ãƒªã€Œ${category}ã€ã‚’å‰Šé™¤ã—ã€${count}ä»¶ã®å–å¼•ã‚’ã€Œ${replacementCategory}ã€ã«å¤‰æ›´ã—ã¾ã—ãŸ`,
                                CONSTANTS.NOTIFICATION_TYPES.SUCCESS
                            );
                        } catch (error) {
                            this.uiManager.notificationManager.show(error.message, CONSTANTS.NOTIFICATION_TYPES.ERROR);
                        }
                    } else {
                        const confirmed = await this.uiManager.modalManager.showConfirm(
                            'ã‚«ãƒ†ã‚´ãƒªã‚’å‰Šé™¤',
                            `ã‚«ãƒ†ã‚´ãƒªã€Œ${category}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`,
                            { confirmText: 'å‰Šé™¤' }
                        );

                        if (confirmed) {
                            try {
                                this.dataManager.removeCategory(type, category);
                                this.updateCategoryList();
                            } catch (error) {
                                this.uiManager.notificationManager.show(error.message, CONSTANTS.NOTIFICATION_TYPES.ERROR);
                            }
                        }
                    }
                }

                async showCategoryReplacementModal(type, categoryToRemove, transactionCount) {
                    return new Promise((resolve) => {
                        const replacementModal = this.uiManager.modalManager.createModal();
                        
                        replacementModal.content.innerHTML = `
                            <h2 class="modal-title"><span aria-hidden="true">âš ï¸</span> ã‚«ãƒ†ã‚´ãƒªã®ç½®ãæ›ãˆ</h2>
                            <p class="modal-text">
                                ã‚«ãƒ†ã‚´ãƒªã€Œ<strong>${categoryToRemove}</strong>ã€ã¯${transactionCount}ä»¶ã®å–å¼•ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚<br>
                                å‰Šé™¤ã™ã‚‹å‰ã«ã€ã“ã‚Œã‚‰ã®å–å¼•ã‚’åˆ¥ã®ã‚«ãƒ†ã‚´ãƒªã«å¤‰æ›´ã—ã¦ãã ã•ã„ã€‚
                            </p>
                            <div style="margin-bottom: 20px;">
                                <label style="display: block; margin-bottom: 5px; font-weight: 600;">ç½®ãæ›ãˆå…ˆã®ã‚«ãƒ†ã‚´ãƒª:</label>
                                <select id="replacementCategory" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                    <option value="">é¸æŠã—ã¦ãã ã•ã„</option>
                                    ${this.dataManager.categories[type]
                                        .filter(cat => cat !== categoryToRemove)
                                        .map(cat => `<option value="${cat}">${cat}</option>`)
                                        .join('')}
                                </select>
                            </div>
                            <div class="modal-buttons">
                                <button class="btn btn-secondary" data-action="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                                <button class="btn btn-primary" data-action="confirm">å¤‰æ›´ã—ã¦å‰Šé™¤</button>
                            </div>
                        `;

                        const handleClose = (result) => {
                            this.uiManager.modalManager.closeModal(replacementModal.overlay);
                            resolve(result);
                        };

                        replacementModal.content.addEventListener('click', (e) => {
                            if (e.target.dataset.action === 'confirm') {
                                const replacement = document.getElementById('replacementCategory').value;
                                if (replacement) {
                                    handleClose(replacement);
                                } else {
                                    this.uiManager.notificationManager.show('ç½®ãæ›ãˆå…ˆã®ã‚«ãƒ†ã‚´ãƒªã‚’é¸æŠã—ã¦ãã ã•ã„', CONSTANTS.NOTIFICATION_TYPES.ERROR);
                                }
                            } else if (e.target.dataset.action === 'cancel') {
                                handleClose(null);
                            }
                        });

                        replacementModal.overlay.addEventListener('click', (e) => {
                            if (e.target === replacementModal.overlay) {
                                handleClose(null);
                            }
                        });

                        replacementModal.escHandler = (e) => {
                            if (e.key === 'Escape') {
                                handleClose(null);
                            }
                        };
                        document.addEventListener('keydown', replacementModal.escHandler);

                        this.uiManager.modalManager.showModal(replacementModal.overlay);
                    });
                }

                close() {
                    this.uiManager.modalManager.closeModal(this.modal.overlay);
                    this.dataManager.saveSettings();
                }
            }

            // æ—¥ä»˜è§£æã‚¯ãƒ©ã‚¹ï¼ˆæ”¹å–„ç‰ˆï¼‰
            class DateParser {
                static SUPPORTED_FORMATS = [
                    { pattern: /^\d{4}-\d{2}-\d{2}$/, name: 'YYYY-MM-DD', example: '2025-01-15' },
                    { pattern: /^\d{4}\/\d{1,2}\/\d{1,2}$/, name: 'YYYY/MM/DD', example: '2025/1/15' },
                    { pattern: /^\d{2}\/\d{1,2}\/\d{1,2}$/, name: 'YY/MM/DD', example: '25/1/15' },
                    { pattern: /^\d{4}å¹´\d{1,2}æœˆ\d{1,2}æ—¥$/, name: 'YYYYå¹´MMæœˆDDæ—¥', example: '2025å¹´1æœˆ15æ—¥' }
                ];

                static formatDateForInput(dateValue) {
                    if (!dateValue) return '';
                    
                    try {
                        let date;
                        
                        // Excel ã‚·ãƒªã‚¢ãƒ«å€¤ã®å‡¦ç†
                        if (typeof dateValue === 'number' && dateValue > 1 && dateValue < 100000) {
                            // Excel ã®åŸºæº–æ—¥ã¯1900å¹´1æœˆ1æ—¥ï¼ˆãŸã ã—1900å¹´2æœˆ28æ—¥ä»¥å‰ã¯1æ—¥ãšã‚Œã‚‹ï¼‰
                            const excelEpoch = new Date(1899, 11, 30);
                            const daysOffset = dateValue > 59 ? dateValue : dateValue - 1; // 1900å¹´ã®é–å¹´ãƒã‚°å¯¾å¿œ
                            date = new Date(excelEpoch.getTime() + daysOffset * 86400 * 1000);
                        } else if (typeof dateValue === 'string') {
                            const dateStr = dateValue.trim();
                            
                            // YYYY-MM-DDå½¢å¼
                            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                                const [year, month, day] = dateStr.split('-').map(Number);
                                date = new Date(year, month - 1, day);
                            }
                            // YYYY/MM/DDå½¢å¼
                            else if (/^\d{4}\/\d{1,2}\/\d{1,2}$/.test(dateStr)) {
                                const [year, month, day] = dateStr.split('/').map(Number);
                                date = new Date(year, month - 1, day);
                            }
                            // YY/MM/DDå½¢å¼
                            else if (/^\d{2}\/\d{1,2}\/\d{1,2}$/.test(dateStr)) {
                                const [year, month, day] = dateStr.split('/').map(Number);
                                const fullYear = year + (year < 50 ? 2000 : 1900);
                                date = new Date(fullYear, month - 1, day);
                            }
                            // YYYYå¹´MMæœˆDDæ—¥å½¢å¼
                            else if (/^\d{4}å¹´\d{1,2}æœˆ\d{1,2}æ—¥$/.test(dateStr)) {
                                const matches = dateStr.match(/(\d{4})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥/);
                                if (matches) {
                                    const [, year, month, day] = matches.map(Number);
                                    date = new Date(year, month - 1, day);
                                }
                            }
                            // ISO 8601å½¢å¼ã‚’ã‚µãƒãƒ¼ãƒˆ
                            else if (/^\d{4}-\d{2}-\d{2}T/.test(dateStr)) {
                                date = new Date(dateStr);
                            }
                            else {
                                // æœ€å¾Œã®æ‰‹æ®µã¨ã—ã¦ Date ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ä»»ã›ã‚‹
                                date = new Date(dateStr);
                            }
                        } else if (dateValue instanceof Date) {
                            date = new Date(dateValue);
                        } else {
                            return '';
                        }

                        if (isNaN(date.getTime())) {
                            console.warn(`ç„¡åŠ¹ãªæ—¥ä»˜: ${dateValue}`);
                            return '';
                        }

                        const year = date.getFullYear();
                        if (year < 1900 || year > 2100) {
                            console.warn(`æ—¥ä»˜ãŒç¯„å›²å¤–: ${year}å¹´`);
                            return '';
                        }

                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const day = String(date.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                        
                    } catch (error) {
                        console.error('æ—¥ä»˜å¤‰æ›ã‚¨ãƒ©ãƒ¼:', error, dateValue);
                        return '';
                    }
                }

                static getSupportedFormatsDescription() {
                    return this.SUPPORTED_FORMATS
                        .map(f => `${f.name} (ä¾‹: ${f.example})`)
                        .join('ã€');
                }
            }

            // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆIndexedDBå¯¾å¿œï¼‰
            class App {
                constructor() {
                    this.dataManager = new HouseholdBudgetData();
                    this.uiManager = new UIManager(this.dataManager);
                    this.init();
                }

                async init() {
                    try {
                        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
                        this.uiManager.showLoading('ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...');
                        
                        // ãƒ‡ãƒ¼ã‚¿ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–ï¼ˆIndexedDBï¼‰
                        await this.dataManager.init();
                        
                        // ä»Šæ—¥ã®æ—¥ä»˜ã‚’è¨­å®š
                        document.getElementById('date').value = new Date().toISOString().split('T')[0];
                        
                        // ã‚«ãƒ†ã‚´ãƒªã®åˆæœŸåŒ–
                        this.uiManager.updateCategoryOptions();
                        this.uiManager.updateFilterCategoryOptions();
                        
                        // ãƒ•ã‚£ãƒ«ã‚¿ã®å¾©å…ƒ
                        setTimeout(() => {
                            document.getElementById('filterType').value = this.dataManager.filters.type || '';
                            document.getElementById('filterCategory').value = this.dataManager.filters.category || '';
                            document.getElementById('filterMonth').value = this.dataManager.filters.month || '';
                            this.uiManager.handleFilterChange();
                        }, 100);
                        
                        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°éè¡¨ç¤º
                        this.uiManager.hideLoading();
                        
                        // èµ·å‹•æ™‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                        if (this.dataManager.transactions.length > 0) {
                            console.log(`${this.dataManager.transactions.length}ä»¶ã®å–å¼•ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
                            this.uiManager.notificationManager.show(
                                `${this.dataManager.transactions.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`,
                                CONSTANTS.NOTIFICATION_TYPES.INFO,
                                2000
                            );
                        }
                        
                        // IndexedDBåˆ©ç”¨å¯èƒ½ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                        if (this.dataManager.isInitialized && this.dataManager.dbManager.db) {
                            console.log('IndexedDBã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’ç®¡ç†ã—ã¦ã„ã¾ã™');
                        }
                        
                    } catch (error) {
                        console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                        this.uiManager.hideLoading();
                        this.uiManager.notificationManager.show(
                            'ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ',
                            CONSTANTS.NOTIFICATION_TYPES.ERROR
                        );
                    }
                }
            }

            // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’èµ·å‹•
            document.addEventListener('DOMContentLoaded', () => {
                new App();
            });
        })();
    </script>
</body>
</html>